### JS中的垃圾回收机制

#### 1. 什么是垃圾回收

> GC(Garbage Collection)。程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，GC就是负责回收垃圾的

'''
  let a = 123
  a = { name: 123}
  
那上面代码首先我们声明了一个变量 test，它引用了对象 {name: 'isboyjc'}，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理

我们都知道JavaScript 的基本类型的数据是保存在栈中的，引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，然后JavaScript 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。

#### 2.垃圾回收的方法

- 标记清除
- 引用计数

#### 3.标记清除

> 大多数浏览器的 JavaScript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript引擎 在运行垃圾回收的频率上有所差异

标记方法:
 - 二进制字符0/1表示标记
 - 两个环境变量列表

标记的过程：

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成1
- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

标记清除的缺点

内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块

分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢

内存分配

First-fit，找到大于等于 size 的块立即返回

Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块

Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回

#### 4.引用计数

引用计数过程

当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1

如果同一个值又被赋给另一个变量，那么引用数加 1

如果该变量的值被其他的值覆盖了，则引用次数减 1

当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

引用计数缺点

- 循环引用

function test(){
  let A = new Object()
  let B = new Object()
  
  A.b = B
  B.a = A
}

如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 test 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放

- 性能问题

它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的

